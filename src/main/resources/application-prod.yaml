spring:
  config:
    activate:
      on-profile: prod
#    # .env 파일을 속성 소스로 추가
    import: optional:file:.env[.properties]
  
  # 운영환경에서는 SQL 초기화 비활성화 (이미 테이블이 존재)
  sql:
    init:
      mode: never

  batch:
    jdbc:
      initialize-schema: never

  # PostgreSQL DB 접속 정보
  datasource:
    url: jdbc:postgresql://${RDS_ENDPOINT}:5432/${RDS_DATABASE}
    username: ${RDS_USERNAME}
    password: ${RDS_PASSWORD}
    driver-class-name: org.postgresql.Driver

  # JPA 설정 (PostgreSQL용)
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: validate  # 운영환경에서는 스키마 검증만
    properties:
      hibernate:
        show_sql: false
        default_batch_fetch_size: 100
        format_sql: false
        dialect: org.hibernate.dialect.PostgreSQLDialect

  elasticsearch:
    health-timeout-ms: 20000
    uris: ${ELASTICSEARCH_URIS:localhost:9200}

  data:
    redis:
      # 단일 노드 설정
      host: ${REDIS_HOST}
      port: ${REDIS_PORT:6380}
      ssl:
        enabled: true
      timeout: 10000ms
      connect-timeout: 10000ms

  kafka:
    bootstrap-servers: ${SPRING_KAFKA_BOOTSTRAP_SERVERS}
    properties:
      security.protocol: SASL_SSL
      sasl.mechanism: PLAIN
      sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="${CONFLUENT_API_KEY}" password="${CONFLUENT_API_SECRET}";
      session.timeout.ms: 45000
      request.timeout.ms: 60000
      reconnect.backoff.ms: 1000
      reconnect.backoff.max.ms: 10000

    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      acks: all  # 모든 복제본에 메시지 저장 확인
      retries: 3 # 실패 시 재시도 횟수

    consumer:
      group-id: ${SPRING_KAFKA_CONSUMER_GROUP_ID:otboo-group}
      auto-offset-reset: latest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      enable-auto-commit: false # 수동 커밋으로 메시지 손실 방지 (메시지 처리 실패 시 재처리 가능)
      properties:
        max.poll.interval.ms: 300000
        heartbeat.interval.ms: 3000
        spring.json.trusted.packages: "com.samsamotot.otboo.*" # 역직렬화 보안

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
      show-components: when-authorized

otboo:
  # 보안 설정
  security:
    cookie:
      secure: true  # 운영환경에서는 true
      same-site: None  # 운영환경에서는 Strict
      domain: samsam-otot.duckdns.org

  # JWT 설정
  jwt:
    secret: ${JWT_SECRET:}
    access-token-expiration: ${JWT_ACCESS_TOKEN_EXPIRATION:3600000}  # 1시간 (밀리초)
    refresh-token-expiration: ${JWT_REFRESH_TOKEN_EXPIRATION:604800000}  # 7일 (밀리초)
    issuer: ${JWT_ISSUER:otboo}

  # CORS 설정
  cors:
    allowed-origins: ${CORS_ALLOWED_ORIGINS:}

  storage:
    type: ${STORAGE_TYPE:local}
    s3:
      access-key: ${AWS_S3_ACCESS_KEY}
      secret-key: ${AWS_S3_SECRET_KEY}
      region: ${AWS_S3_REGION}
      bucket: ${AWS_S3_BUCKET}

logging:
  level:
    org.hibernate.sql: INFO
    org.hibernate.type.descriptor.sql.BasicBinder: INFO
    org.springframework.security.web.access.intercept.FilterSecurityInterceptor: DEBUG
    com.samsamotot.otboo: INFO

websocket:
  allowed-origins: https://samsam-otot.duckdns.org

server:
  port: ${SERVER_PORT:8080}
  forward-headers-strategy: framework
